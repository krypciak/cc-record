

// const fs: typeof import('fs') = (0, eval)("require('fs')")

// const toWav: typeof import('audiobuffer-to-wav') = require('audiobuffer-to-wav')
//
// async function getAudioBuffer(path: string): Promise<{ audioBuffer: AudioBuffer; sound: ig.SoundWebAudio }> {
//     return new Promise(resolve => {
//         const i = setInterval(() => {
//             const sound: ig.SoundWebAudio = new ig.SoundWebAudio(path)
//             const audioBuffer = sound.webAudioBuffer.get()
//             if (audioBuffer) {
//                 clearInterval(i)
//                 resolve({ audioBuffer, sound })
//             }
//         }, 100)
//     })
// }
//
// async function getBufferNode(handle: ig.SoundHandleWebAudio): Promise<AudioBufferSourceNode> {
//     return new Promise(resolve => {
//         const i = setInterval(() => {
//             if (handle._nodeSource?.bufferNode) {
//                 resolve(handle._nodeSource.bufferNode)
//                 clearInterval(i)
//             }
//         }, 10)
//     })
// }
//
// async function saveAudioBuffer(abuffer: AudioBuffer, name: string) {
//     const arraybuffer = toWav(abuffer)
//     const buffer = Buffer.from(arraybuffer)
//
//     const path = `${CCRecord.baseDataPath}/${name}.wav`
//     fs.promises.writeFile(path, buffer)
//     console.log('written', path)
// }


    // ig.myctx = new wae.WebAudioContext({
    //     context: new AudioContext(),
    // })
    // const context = new wae.StreamAudioContext()
    //
    // const { audioBuffer: origAudioBuffer } = await getAudioBuffer('media/sound/boss/fire-spirit/fire-spirit-grunt.ogg')

    {
        // const source = new wae.impl.AudioBufferSourceNode(context, {
        //     buffer: origAudioBuffer,
        // })
        // source
        // source.connect(context.destination)
        // source.start()
    }
